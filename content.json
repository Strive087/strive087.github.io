{"meta":{"title":"前端之路","subtitle":"","description":"","author":"zhuduanlei","url":"http://strive087.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-15T11:38:06.167Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"404.html","permalink":"http://strive087.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-07-15T11:38:06.167Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"about/index.html","permalink":"http://strive087.github.io/about/index.html","excerpt":"","text":"网站说明 本站纯粹记录个人学习成果，若有侵犯，通知本人，必定删除。 email: 840459919@qq.com"},{"title":"所有分类","date":"2020-07-15T11:38:06.167Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"categories/index.html","permalink":"http://strive087.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-15T11:38:06.167Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"tags/index.html","permalink":"http://strive087.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"散列表（哈希表）","slug":"algorithm/散列表","date":"2020-07-11T23:05:49.000Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"2020/07/11/algorithm/散列表/","link":"","permalink":"http://strive087.github.io/2020/07/11/algorithm/%E6%95%A3%E5%88%97%E8%A1%A8/","excerpt":"","text":"什么是散列表 在职场中，我们每个人在公司内部都有一个唯一的工号工号，这就如同散列表的key值。而工号对应着你的个人信息，就如同散列表中key对应的数据value。散列表本质由数组构成，通过哈希函数将key转换成数组的下标index，数组的下标index对应到相应的数据value。 哈希函数 每种编程语言实现哈希函数的算法都有不同，这里以Java的常用集合 HashMap为例，来看一看哈希函数在Java中的实现。 在Java及大多数面向对象的语言中，每一个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。 既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的转化方式是什么呢？是按照数组长度进行取模运算。 1index &#x3D; HashCode (Key) % Array.length 实际上，JDK（Java Development Kit，Java语言的软件开发工具包）中的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化性能。不过在这里可以姑且简单理解成取模操作。 通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标index。 哈希冲突 由于数组长度有限，当key值通过哈希函数转换成index时，就会可能会出现不同的key值转换成相同的index，这种情况就称为哈希冲突。解决哈希冲突有开放寻址法、拉链法和再哈希法等等。这里主要介绍开放寻址法和拉链法。 开放寻址法 点击查看更多 数据插入开放寻址法的原理很简单，当一个Key通过哈希函数获得对应的数组下标已被占 用时，我们可以“另谋高就”，寻找下一个空档位置。数据查询散列表查询根据key通过哈希函数得到index后对比数据是否相同，如果不同则遍历数组中的数据,如果找到一个空闲的空间则说明该数组中并无该数据。因为在插入数据的时候，遇到相同index的key值后便会遍历数组找到空闲空间进行插入，倘若在查询遍历时找到空闲空间，则表示数组中并没有插入对应key值的value数据。数据删除因为在数据查询的过程中，我们把遍历数组时遇到空闲的空间的情况认定为在数组中无此数据。所以在删除时，不能单单只是地把对应的数据设置为空，因为这操作可能是在插入之后，这将影响到查询。遇到这种情况，通常可以将删除数据设置为空，并从删除位置开始遍历数据组将不为空的数据重新通过哈希函数插入，这将避免直接设置为空给查询带来影响。另一种方法是标记法，可以将要删除的数据打上删除标记，之后查询的时遇到该标记就跳过，而插入时遇到该标记便可看为空闲的空间插入。装载因子你会发现当散列表插入的数据越来越多时，发生哈希冲突的可能将会上升，同时线性探测数据的方法的时间也会增加。极端状况下将探测整个数组，时间复杂度为O(n)。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子(load factor)来表示空位的多少。散列表的装载因子=填入表中的元素个数/散列表的长度散列表的装载因子越大，空闲的空间越少，哈希冲突发生概率越高。 拉链法 点击查看更多 数据插入拉链法又称链表法，每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。数据查询数据查询时根据哈希函数得到index，根据链表的头结点，遍历链表找到对应key值的数据。数据删除数据删除时首先跟查询操作相同找到数据，然后做链表删除操作即可。 javasrcipt实现散列表(使用拉链法简单实现) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class entry&#123; constructor(key,value)&#123; this.data = &#123; key : key, value : value, &#125;; this.next = null; &#125;&#125;class linkedList&#123; last = null; size = 0; constructor()&#123; this.head = new entry(); &#125; insert(entry)&#123; if(this.head.next == null)&#123; this.head.next = entry; this.last = entry; this.size++; &#125;else&#123; this.last.next = entry; this.last = entry; this.size++; &#125; &#125; delete(key)&#123; var entry = this.head; while(entry.next)&#123; if(entry.next.data.key == key)&#123; if(entry.next.next)&#123; entry.next = entry.next.next; &#125;else&#123; entry.next = null; &#125; if(this.last.data.key == key)&#123; this.last = entry; &#125; this.size--; return 'success'; &#125;else&#123; entry = entry.next; &#125; &#125; return 'fail'; &#125; find(key)&#123; var entry = this.head; while(entry.next)&#123; if(entry.next.data.key == key)&#123; return entry.next.data.value; &#125;else&#123; entry = entry.next; &#125; &#125; return undefined; &#125; update(key,value)&#123; var entry = this.head; while(entry.next)&#123; if(entry.next.data.key == key)&#123; entry.next.data.value = value; return 'success'; &#125;else&#123; entry = entry.next; &#125; &#125; return 'not found'; &#125;&#125;class hashTable&#123; #size = 10; constructor(size)&#123; this.tableArr = []; if(size)&#123; this.#size = size; &#125; for(let i = 0; i &lt; this.#size ; i++)&#123; this.tableArr[i] = new linkedList(); &#125; &#125; hashFunc(key)&#123; let hash = 0; for(let i = 0; i &lt; key.length; ++i)&#123; hash += key.charCodeAt(i); &#125; return hash % this.#size; &#125; set(key,value)&#123; let index = this.hashFunc(key); if(this.get(key) == undefined)&#123; this.tableArr[index].insert(new entry(key,value)); &#125;else&#123; this.tableArr[index].update(key,value) &#125; &#125; get(key)&#123; let index = this.hashFunc(key); return this.tableArr[index].find(key); &#125; remove(key)&#123; let index = this.hashFunc(key); this.tableArr[index].delete(key); &#125;&#125;var map = new hashTable();map.set(1,1);map.set(2,2);map.set(3,3);map.set(4,4);map.set(5,5);map.set(6,6);map.set(7,7);map.set(8,8);map.set(9,9);map.set(10,10);map.set(11,11);map.set(12,12);map.set(13,13);console.log(map.get(12));map.remove(12);console.log(map.get(12));console.log(map.get(6));map.set(6,-6);console.log(map.get(6));","categories":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"散列表","slug":"算法/散列表","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"散列表","slug":"散列表","permalink":"http://strive087.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"哈希表","slug":"哈希表","permalink":"http://strive087.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"基本概念","slug":"algorithm/基本概念","date":"2020-07-06T23:05:49.000Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"2020/07/06/algorithm/基本概念/","link":"","permalink":"http://strive087.github.io/2020/07/06/algorithm/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"算法 在数学领域里，算法是用于解决某一类 问题的公式和思想。计算机科学领域的算法，它的本质是一系列程序指令，用于解决特定的运算和逻辑问题。 数据结构 数据结构是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。 时间复杂度 如何推导出时间复杂度呢？有如下几个原则。 如果运行时间是常数量级，则用常数1表示 只保留时间函数中的最高阶项 如果最高阶项存在，则省去最高阶项前面的系数 常见的四种时间复杂度执行时间排序：O(1)&lt;O(logn)&lt;O(n)&lt;O(n2)在编程的世界中有各种各样的算法，除了上述4个场景，还有许多不同形式的时 间复杂度，例如：O(nlogn)、O(n3)、O(mn)、O(2n)、O(n!) 空间复杂度 在运行一段程序时，我们不仅要执行各种运算指令，同时也会根据需要，存储一些临时的中间数据，以便后续指令可以更方便地继续执行。这些临时的中间数据在运行过程中所占用的内存空间自然是越小越好，那么空间复杂度便是评判其占用大小的标准。常见的空间复杂度有下面几种情形。 常量空间当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)。 线性空间当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。 二维空间当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n2)。 递归空间递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。 时间与空间的取舍 在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间， 也要提升程序的执行速度。 最大公约数 如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b), 同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。可以在区块中放置一些复杂的结构，支持嵌套。求法： 质因数分解法 点击查看更多 把每个数分别分解质因数，再把各数中的全部公有质因数提取出来连乘，所得的积就是这几个数的最大公约数。例如：求24和60的最大公约数，先分解质因数，得24=2×2×2×3，60=2×2×3×5，24与60的全部公有的质因数是2、2、3，它们的积是2×2×3=12，所以，（24，60）=12。 短除法 点击查看更多 短除法求最大公约数，先用这几个数的公约数连续去除，一直除到所有的商互质为止，然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数。 辗转相除法 点击查看更多 辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。例如，求（319，377）：∵ 319÷377=0（余319）∴（319，377）=（377，319）；∵ 377÷319=1（余58）∴（377，319）=（319，58）；∵ 319÷58=5（余29）∴ （319，58）=（58，29）；∵ 58÷29=2（余0）∴ （58，29）= 29；∴ （319，377）=29。可以写成右边的格式。用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。 更相减损法 点击查看更多 更相减损法：也叫更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。例1．用更相减损术求98与63的最大公约数。解：由于63不是偶数，把98和63以大数减小数，并辗转相减：98-63=3563-35=2835-28=728-7=2121-7=1414-7=7所以，98和63的最大公约数等于7。这个过程可以简单的写为：（98，63）=（35，63）=（35，28）=（7，28）=（7，21）=（7，14）=（7，7）=7.例2．用更相减损术求260和104的最大公约数。解：由于260和104均为偶数，首先用2约简得到130和52，再用2约简得到65和26。此时65是奇数而26不是奇数，故把65和26辗转相减：65-26=3939-26=1326-13=13所以，260与104的最大公约数等于13乘以第一步中约掉的两个2，即1322=52。这个过程可以简单地写为：（260,104）(/2/2) =&gt;（65,26）=（39,26）=（13,26）=（13,13）=13. (22) =&gt; 52 比较辗转相除法与更相减损术的区别都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。 物理结构与逻辑结构 常用的数据结构有很多，但大多数以数组和链表作为主要的存储方式，数组和链表可以看做数据结构的”物理结构”。","categories":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基本概念","slug":"算法/基本概念","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JS的函数式编程","slug":"JS函数式编程","date":"2020-06-11T12:05:50.000Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"2020/06/11/JS函数式编程/","link":"","permalink":"http://strive087.github.io/2020/06/11/JS%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"函数式编程特点： 函数是”第一等公民” (与变量的) 只用”表达式”，不用”语句” 没有”副作用” 不修改状态 引用透明（函数运行只靠参数） 函数curry多参数函数转化成一个嵌套的一元函数好处：一种函数的预加载的方法,相当于-缓存，保存作用域链闭包必定会有内存泄漏","categories":[{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/categories/javascript/"},{"name":"函数式编程","slug":"javascript/函数式编程","permalink":"http://strive087.github.io/categories/javascript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/tags/javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://strive087.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"JS的词法作用域","slug":"JS的词法作用域","date":"2020-06-10T23:05:49.000Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"2020/06/10/JS的词法作用域/","link":"","permalink":"http://strive087.github.io/2020/06/10/JS%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"作用域 说到词法作用域，我们先讲讲什么是作用域。其实作用域就是一套用来存储变量以及快速查找变量的一套的规则。java 词法作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/categories/javascript/"},{"name":"作用域","slug":"javascript/作用域","permalink":"http://strive087.github.io/categories/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/tags/javascript/"},{"name":"作用域","slug":"作用域","permalink":"http://strive087.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"}]},{"title":"npm切换镜像源","slug":"npm","date":"2020-06-07T12:20:35.000Z","updated":"2020-07-15T11:38:06.167Z","comments":true,"path":"2020/06/07/npm/","link":"","permalink":"http://strive087.github.io/2020/06/07/npm/","excerpt":"","text":"切换为淘宝镜像 1.临时使用 npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install express; 2.持久使用 npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 3.通过cnpm npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 切换官方镜像 npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F; 查看当前npm源地址 npm config get registry","categories":[{"name":"nodeJs","slug":"nodeJs","permalink":"http://strive087.github.io/categories/nodeJs/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://strive087.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"http://strive087.github.io/tags/nodejs/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"散列表","slug":"算法/散列表","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"基本概念","slug":"算法/基本概念","permalink":"http://strive087.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/categories/javascript/"},{"name":"函数式编程","slug":"javascript/函数式编程","permalink":"http://strive087.github.io/categories/javascript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"作用域","slug":"javascript/作用域","permalink":"http://strive087.github.io/categories/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"nodeJs","slug":"nodeJs","permalink":"http://strive087.github.io/categories/nodeJs/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://strive087.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"散列表","slug":"散列表","permalink":"http://strive087.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"哈希表","slug":"哈希表","permalink":"http://strive087.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"javascript","slug":"javascript","permalink":"http://strive087.github.io/tags/javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://strive087.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"作用域","slug":"作用域","permalink":"http://strive087.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"npm","slug":"npm","permalink":"http://strive087.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"http://strive087.github.io/tags/nodejs/"}]}