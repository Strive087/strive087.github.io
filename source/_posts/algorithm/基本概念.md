---
layout: post
title: 基本概念
date: 2020-07-07 07:05:49
tags: [算法]
categories : [算法,基本概念]
---
{% p subtitle, 算法 %}
在数学领域里，算法是用于解决某一类 问题的公式和思想。
计算机科学领域的算法，它的本质是一系列程序指令，用于解决特定的运算和逻辑问题。

{% p subtitle, 数据结构 %}
数据结构是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。
数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。

{% p subtitle, 时间复杂度 %}
如何推导出时间复杂度呢？有如下几个原则。  

* 如果运行时间是常数量级，则用常数1表示
* 只保留时间函数中的最高阶项  
* 如果最高阶项存在，则省去最高阶项前面的系数

常见的四种时间复杂度执行时间排序：
O(1)<O(logn)<O(n)<O(n2)
在编程的世界中有各种各样的算法，除了上述4个场景，还有许多不同形式的时 间复杂度，例如：O(nlogn)、O(n3)、O(mn)、O(2n)、O(n!)

{% p subtitle, 空间复杂度 %}
在运行一段程序时，我们不仅要执行各种运算指令，同时也会根据需要，存储一些临时的中间数据，以便后续指令可以更方便地继续执行。
这些临时的中间数据在运行过程中所占用的内存空间自然是越小越好，那么空间复杂度便是评判其占用大小的标准。
常见的空间复杂度有下面几种情形。

1. 常量空间  
当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)。
2. 线性空间  
当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。
3. 二维空间  
当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n2)。
4. 递归空间  
递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。

{% p subtitle, 时间与空间的取舍 %}
在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间， 也要提升程序的执行速度。

{% p subtitle, 最大公约数 %}
如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。
最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b), 同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。
可以在区块中放置一些复杂的结构，支持嵌套。
求法：
{% noteblock quote %}

{% p subtitle, 质因数分解法 %}
{% folding 点击查看更多 %}
把每个数分别分解质因数，再把各数中的全部公有质因数提取出来连乘，所得的积就是这几个数的最大公约数。
例如：求24和60的最大公约数，先分解质因数，得24=2×2×2×3，60=2×2×3×5，24与60的全部公有的质因数是2、2、3，它们的积是2×2×3=12，所以，（24，60）=12。
{% endfolding %}

{% p subtitle, 短除法 %}
{% folding 点击查看更多 %}
短除法求最大公约数，先用这几个数的公约数连续去除，一直除到所有的商互质为止，然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数。
{% endfolding %}

{% p subtitle, 辗转相除法 %}
{% folding 点击查看更多 %}
辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。
例如，求（319，377）：
∵ 319÷377=0（余319）
∴（319，377）=（377，319）；
∵ 377÷319=1（余58）
∴（377，319）=（319，58）；
∵ 319÷58=5（余29）
∴ （319，58）=（58，29）；
∵ 58÷29=2（余0）
∴ （58，29）= 29；
∴ （319，377）=29。
可以写成右边的格式。
用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。
{% endfolding %}

{% p subtitle, 更相减损法 %}
{% folding 点击查看更多 %}
更相减损法：也叫更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。
第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。
第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。
则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。
其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。
例1．用更相减损术求98与63的最大公约数。
解：由于63不是偶数，把98和63以大数减小数，并辗转相减：
98-63=35
63-35=28
35-28=7
28-7=21
21-7=14
14-7=7
所以，98和63的最大公约数等于7。
这个过程可以简单的写为：
（98，63）=（35，63）=（35，28）=（7，28）=（7，21）=（7，14）=（7，7）=7.
例2．用更相减损术求260和104的最大公约数。
解：由于260和104均为偶数，首先用2约简得到130和52，再用2约简得到65和26。
此时65是奇数而26不是奇数，故把65和26辗转相减：
65-26=39
39-26=13
26-13=13
所以，260与104的最大公约数等于13乘以第一步中约掉的两个2，即13*2*2=52。
这个过程可以简单地写为：
（260,104）(/2/2) =>（65,26）=（39,26）=（13,26）=（13,13）=13. (*2*2) => 52
{% endfolding %}

{% p subtitle, 比较辗转相除法与更相减损术的区别 %}

1. 都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。

2. 从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。

{% endnoteblock %}

{% p subtitle, 物理结构与逻辑结构 %}
常用的数据结构有很多，但大多数以数组和链表作为主要的存储方式，数组和链表可以看做数据结构的"物理结构"。
{% image http://106.53.255.182:9608/images/algorithm_datastructure.png, 500px %}  
